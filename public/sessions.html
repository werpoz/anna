<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Anna Sessions Lab</title>
    <style>
      :root {
        --bg: #0b0f1a;
        --bg-2: #101b2d;
        --panel: rgba(18, 27, 45, 0.82);
        --panel-2: rgba(13, 18, 30, 0.92);
        --ink: #e6edf5;
        --muted: #97a3b6;
        --accent: #00d4a6;
        --accent-2: #ff8a3d;
        --stroke: rgba(255, 255, 255, 0.08);
        --glow: rgba(0, 212, 166, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Avenir Next", "Avenir", "Segoe UI", sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 10% 20%, rgba(0, 212, 166, 0.12), transparent 40%),
          radial-gradient(circle at 90% 0%, rgba(255, 138, 61, 0.2), transparent 35%),
          linear-gradient(130deg, var(--bg), var(--bg-2));
        min-height: 100vh;
      }

      header {
        padding: 32px 8vw 16px;
      }

      h1 {
        margin: 0 0 6px;
        font-weight: 700;
        font-size: clamp(28px, 4vw, 42px);
        letter-spacing: -0.02em;
      }

      p {
        margin: 0;
        color: var(--muted);
        max-width: 760px;
      }

      .grid {
        display: grid;
        gap: 20px;
        padding: 24px 8vw 48px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .card {
        background: var(--panel);
        border: 1px solid var(--stroke);
        border-radius: 18px;
        padding: 20px;
        box-shadow: 0 20px 40px rgba(5, 8, 18, 0.4);
        backdrop-filter: blur(14px);
        animation: floatIn 0.6s ease forwards;
        opacity: 0;
        transform: translateY(12px);
      }

      .card:nth-child(2) {
        animation-delay: 0.08s;
      }

      .card:nth-child(3) {
        animation-delay: 0.16s;
      }

      @keyframes floatIn {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        margin-bottom: 6px;
      }

      input,
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        background: var(--panel-2);
        color: var(--ink);
        font-size: 14px;
      }

      textarea {
        min-height: 72px;
        resize: vertical;
      }

      .stack {
        display: grid;
        gap: 12px;
      }

      .buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      button {
        border: none;
        padding: 10px 16px;
        border-radius: 999px;
        background: var(--accent);
        color: #04130d;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 24px var(--glow);
      }

      button.secondary {
        background: transparent;
        border: 1px solid var(--stroke);
        color: var(--ink);
        box-shadow: none;
      }

      button.warn {
        background: var(--accent-2);
        color: #2b1300;
        box-shadow: 0 12px 24px rgba(255, 138, 61, 0.3);
      }

      button:hover {
        transform: translateY(-1px);
      }

      .status {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
        font-size: 14px;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: rgba(12, 18, 30, 0.6);
        font-size: 12px;
        color: var(--muted);
      }

      .pill.live {
        color: var(--accent);
        border-color: rgba(0, 212, 166, 0.4);
      }

      .qr-box {
        border: 1px dashed rgba(255, 255, 255, 0.18);
        padding: 14px;
        border-radius: 12px;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 12px;
        color: var(--muted);
        min-height: 120px;
        white-space: pre-wrap;
        word-break: break-all;
      }

      .qr-image {
        width: 100%;
        max-width: 240px;
        background: #fff;
        border-radius: 12px;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .log {
        background: rgba(7, 10, 18, 0.9);
        border-radius: 12px;
        padding: 12px;
        max-height: 360px;
        overflow: auto;
        border: 1px solid rgba(255, 255, 255, 0.06);
        font-family: "JetBrains Mono", "Fira Code", monospace;
        font-size: 12px;
      }

      .log-entry {
        padding: 10px;
        border-radius: 10px;
        background: rgba(15, 20, 35, 0.6);
        margin-bottom: 10px;
      }

      .log-entry:last-child {
        margin-bottom: 0;
      }

      .tag {
        display: inline-block;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--accent);
      }

      .muted {
        color: var(--muted);
      }

      .split {
        display: grid;
        gap: 16px;
      }

      @media (min-width: 920px) {
        .split {
          grid-template-columns: 1.1fr 0.9fr;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="module">
      import React, { useEffect, useMemo, useRef, useState } from 'https://esm.sh/react@18.3.1';
      import { createRoot } from 'https://esm.sh/react-dom@18.3.1/client';
      import htm from 'https://esm.sh/htm@3.1.1';
      import * as QRCode from 'https://esm.sh/qrcode@1.5.4';

      const html = htm.bind(React.createElement);

      const useLocalStorageState = (key, initialValue) => {
        const [value, setValue] = useState(() => {
          const stored = localStorage.getItem(key);
          return stored ?? initialValue;
        });

        useEffect(() => {
          if (value === null || value === undefined) {
            localStorage.removeItem(key);
          } else {
            localStorage.setItem(key, value);
          }
        }, [key, value]);

        return [value, setValue];
      };

      const App = () => {
        const [email, setEmail] = useLocalStorageState('sessionLab.email', '');
        const [token, setToken] = useLocalStorageState('sessionLab.token', '');
        const [sessionId, setSessionId] = useLocalStorageState('sessionLab.sessionId', '');
        const [password, setPassword] = useState('');
        const [wsStatus, setWsStatus] = useState('ws: idle');
        const [wsLive, setWsLive] = useState(false);
        const [sessionStatus, setSessionStatus] = useState('session: idle');
        const [sessionLive, setSessionLive] = useState(false);
        const [qr, setQr] = useState('Waiting for QR...');
        const [qrImage, setQrImage] = useState('');
        const [qrExpires, setQrExpires] = useState('expires: -');
        const [logEntries, setLogEntries] = useState([]);
        const [messageTo, setMessageTo] = useState('');
        const [messageContent, setMessageContent] = useState('');
        const wsRef = useRef(null);
        const qrVersionRef = useRef(0);

        const buildQrDataUrl = async (value) => {
          const fn = QRCode.toDataURL ?? QRCode.default?.toDataURL ?? QRCode.default;
          if (typeof fn !== 'function') {
            throw new Error('QRCode.toDataURL is not available');
          }
          return await fn(value, { margin: 1, width: 240 });
        };

        const appendLog = (type, payload) => {
          const entry = {
            id: crypto.randomUUID(),
            type,
            time: new Date().toLocaleTimeString(),
            payload,
          };
          setLogEntries((prev) => [entry, ...prev].slice(0, 100));
        };

        const ensureToken = () => {
          if (!token.trim()) {
            alert('Access token is required');
            return null;
          }
          return token.trim();
        };

        const ensureSessionId = () => {
          if (!sessionId.trim()) {
            return null;
          }
          return sessionId.trim();
        };

        const connectWs = () => {
          const authToken = ensureToken();
          if (!authToken) return;

          if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
            return;
          }

          const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
          const wsUrl = `${protocol}://${location.host}/ws/sessions?accessToken=${encodeURIComponent(authToken)}`;
          const socket = new WebSocket(wsUrl);
          wsRef.current = socket;

          socket.addEventListener('open', () => {
            setWsStatus('ws: connected');
            setWsLive(true);
          });

          socket.addEventListener('close', () => {
            setWsStatus('ws: closed');
            setWsLive(false);
          });

          socket.addEventListener('error', () => {
            setWsStatus('ws: error');
            setWsLive(false);
          });

          socket.addEventListener('message', (event) => {
            try {
              const data = JSON.parse(event.data);
              appendLog(data.type || 'event', data);

              if (data.type === 'session.qr.updated') {
                setQr(data.payload.qr);
                setQrExpires(`expires: ${data.payload.expiresAt}`);
                setSessionStatus('session: pending_qr');
                setSessionLive(true);
                const version = ++qrVersionRef.current;
                buildQrDataUrl(data.payload.qr)
                  .then((url) => {
                    if (qrVersionRef.current === version) {
                      setQrImage(url);
                    }
                  })
                  .catch(() => {
                    if (qrVersionRef.current === version) {
                      setQrImage('');
                    }
                  });
              }

              if (data.type === 'session.status.connected') {
                setSessionStatus('session: connected');
                setSessionLive(true);
              }

              if (data.type === 'session.status.disconnected') {
                setSessionStatus('session: disconnected');
                setSessionLive(false);
              }
            } catch (error) {
              appendLog('parse_error', { message: String(error) });
            }
          });
        };

        const disconnectWs = () => {
          if (wsRef.current) {
            wsRef.current.close();
          }
        };

        const login = async () => {
          const emailValue = email.trim();
          if (!emailValue || !password) {
            alert('Email and password are required');
            return;
          }

          const response = await fetch('/auth/login', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ email: emailValue, password }),
          });

          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            alert(payload.message || 'Login failed');
            return;
          }

          if (payload.accessToken) {
            setToken(payload.accessToken);
            setPassword('');
            appendLog('auth.login', payload);
          }
        };

        const startSession = async () => {
          const authToken = ensureToken();
          if (!authToken) return;

          const id = ensureSessionId();
          const response = await fetch('/sessions', {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${authToken}`,
              'Content-Type': 'application/json',
            },
            body: id ? JSON.stringify({ sessionId: id }) : null,
          });

          const payload = await response.json();
          appendLog('session.start', payload);
          if (payload.sessionId) {
            setSessionId(payload.sessionId);
          }
        };

        const stopSession = async () => {
          const authToken = ensureToken();
          if (!authToken) return;

          const id = ensureSessionId();
          if (!id) {
            alert('Session ID is required');
            return;
          }

          const response = await fetch(`/sessions/${id}/stop`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${authToken}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ reason: 'manual_stop' }),
          });

          const payload = await response.json();
          appendLog('session.stop', payload);
        };

        const deleteSession = async () => {
          const authToken = ensureToken();
          if (!authToken) return;

          const id = ensureSessionId();
          if (!id) {
            alert('Session ID is required');
            return;
          }

          const response = await fetch(`/sessions/${id}`, {
            method: 'DELETE',
            headers: {
              Authorization: `Bearer ${authToken}`,
            },
          });

          const payload = await response.json();
          appendLog('session.delete', payload);
          setSessionId('');
          setQr('Waiting for QR...');
          setQrImage('');
          setQrExpires('expires: -');
          setSessionStatus('session: idle');
          setSessionLive(false);
        };
        const sendMessage = async () => {
          const authToken = ensureToken();
          if (!authToken) return;

          const id = ensureSessionId();
          if (!id) {
            alert('Session ID is required');
            return;
          }

          const to = messageTo.trim();
          const content = messageContent.trim();

          if (!to || !content) {
            alert('to and content are required');
            return;
          }

          const response = await fetch(`/sessions/${id}/messages`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${authToken}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ to, content }),
          });

          const payload = await response.json();
          appendLog('session.sendMessage', payload);
        };

        const clearLog = () => {
          setLogEntries([]);
        };

        useEffect(() => {
          return () => {
            if (wsRef.current) {
              wsRef.current.close();
            }
          };
        }, []);

        return html`
          <div>
            <header>
              <h1>Anna Sessions Lab</h1>
              <p>
                Quick UI to start sessions, listen to realtime updates, and fire messages. Events are streamed via
                WebSocket and filtered by your tenant.
              </p>
            </header>
            <section className="grid">
              <div className="card">
                <div className="stack">
                  <div>
                    <label>Email</label>
                    <input value=${email} onInput=${(e) => setEmail(e.target.value)} placeholder="you@example.com" />
                  </div>
                  <div>
                    <label>Password</label>
                    <input
                      value=${password}
                      type="password"
                      onInput=${(e) => setPassword(e.target.value)}
                      placeholder="••••••••"
                    />
                  </div>
                  <div>
                    <label>Access token</label>
                    <input
                      value=${token}
                      onInput=${(e) => setToken(e.target.value)}
                      placeholder="Bearer token"
                    />
                  </div>
                  <div>
                    <label>Session ID (optional)</label>
                    <input
                      value=${sessionId}
                      onInput=${(e) => setSessionId(e.target.value)}
                      placeholder="Leave empty to auto-generate"
                    />
                  </div>
                  <div className="buttons">
                    <button onClick=${login}>Login</button>
                    <button onClick=${connectWs}>Connect WS</button>
                    <button className="secondary" onClick=${disconnectWs}>Disconnect</button>
                  </div>
                  <div className="buttons">
                    <button onClick=${startSession}>Start session</button>
                    <button className="warn" onClick=${stopSession}>Stop session</button>
                    <button className="secondary" onClick=${deleteSession}>Delete session</button>
                  </div>
                  <div className="status">
                    <span className=${`pill ${wsLive ? 'live' : ''}`}>${wsStatus}</span>
                    <span className=${`pill ${sessionLive ? 'live' : ''}`}>${sessionStatus}</span>
                  </div>
                </div>
              </div>

              <div className="card split">
                <div className="stack">
                  <div>
                    <label>QR payload</label>
                    ${qrImage
                      ? html`<img className="qr-image" src=${qrImage} alt="QR code" />`
                      : html`<div className="qr-box">${qr}</div>`}
                    <div className="status">
                      <span className="pill">${qrExpires}</span>
                    </div>
                  </div>
                  <div>
                    <label>Send message</label>
                    <input
                      value=${messageTo}
                      onInput=${(e) => setMessageTo(e.target.value)}
                      placeholder="to (jid)"
                    />
                  </div>
                  <div>
                    <textarea
                      value=${messageContent}
                      onInput=${(e) => setMessageContent(e.target.value)}
                      placeholder="message content"
                    ></textarea>
                  </div>
                  <div className="buttons">
                    <button onClick=${sendMessage}>Send message</button>
                    <button className="secondary" onClick=${clearLog}>Clear log</button>
                  </div>
                </div>
                <div>
                  <label>Event stream</label>
                  <div className="log">
                    ${logEntries.map(
                      (entry) => html`
                        <div className="log-entry" key=${entry.id}>
                          <div className="tag">${entry.type}</div>
                          <div className="muted">${entry.time}</div>
                          <pre>${JSON.stringify(entry.payload, null, 2)}</pre>
                        </div>
                      `
                    )}
                  </div>
                </div>
              </div>
            </section>
          </div>
        `;
      };

      const root = createRoot(document.getElementById('root'));
      root.render(html`<${App} />`);
    </script>
  </body>
</html>
